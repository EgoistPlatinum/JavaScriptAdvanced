'use strict'

async function allProducts() {
  const response = await fetch(`https://dummyjson.com/products`)
  return response.json()
}

async function getProduct(id) {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`)
  return response.json()
}

async function getError(id) {
  const response = await fetch(`https://fakestoreapia.com/products/${id}`)
  return response.json()
}

// async function main() {
//   const {products} = await allProducts()
//
//   const res = Promise.all(products.map((product) => getProduct(product)))
//
//   console.log(res)
//
//   // for (const product of products) {
//   //   const res = await getProduct(product.id)
//   //   console.log(res)
//   // }
//
// }
//
// main()

//Введение
// В лекции рассмотрим, как оптимизировать выполнение асинхронных запросов, выполнив их не последовательно, а параллельно.
//
// Основная Проблема
// Пример: Последовательное получение данных о продуктах. Сначала получаем список всех продуктов, затем для каждого продукта отправляем отдельный запрос, чтобы получить детальную информацию.
// Результат: Запросы выполняются по очереди, что замедляет общее время выполнения.
// Решение: Использование Promise.all
// Шаг 1: Базовый Пример
// Отправка нескольких асинхронных запросов параллельно с использованием Promise.all.
// Promise.all принимает массив промисов и возвращает промис, который разрешается, когда все промисы в массиве разрешены.
// Демонстрация того, что при отказе одного промиса, возвращаемый Promise.all промис также отклоняется.
// Шаг 2: Практическое Применение
// Преобразование списка идентификаторов продуктов в массив промисов, каждый из которых запрашивает детали продукта.
// Использование Promise.all для параллельного выполнения всех этих запросов.
// Демонстрация ускорения процесса получения данных, по сравнению с последовательным выполнением.
// Пример Кода
// Пример функции для запроса всех продуктов и отдельной функции для запроса деталей продукта по ID.
// Использование цикла и Promise.all для оптимизации процесса получения детальной информации.
// Видимые Результаты
// Существенное снижение общего времени выполнения за счет параллельной обработки запросов.
// Визуализация ускорения в панели Network браузера.


async function main() {
  const {products} = await allProducts()

  const res1 = Promise.all([getProduct(1), getProduct(2), getProduct(3), getProduct(4), getError(5)])
  console.log(res1)

  const res2 = Promise.allSettled([getProduct(1), getProduct(2), getProduct(3), getProduct(4), getError(5)])
  console.log(res2)

  const res3 = Promise.race([getProduct(1), getProduct(2), getProduct(3), getProduct(4), getError(5)])
  console.log(res3)

}

main()

//Статические методы Promise: Обзор и использование
// Введение в статические методы Promise
// Promise.all: выполняет параллельно массив Promise’ов и возвращает результат при успешном выполнении всех. Если хоть один обещание (Promise) завершается с ошибкой, весь метод возвращает ошибку.
// Promise.allSettled: выполняет массив Promise’ов и возвращает результат для каждого, независимо от успешного выполнения или ошибки. Результат содержит статус (fulfilled или rejected) и значение или причину отказа.
// Различия между Promise.all и Promise.allSettled
// Promise.all
// Возвращает массив результатов при успехе.
// В случае ошибки в любом из Promise, возвращает ошибку и прекращает дальнейшую обработку.
// Promise.allSettled
// Всегда возвращает массив результатов для всех Promise, независимо от их исхода.
// Каждый результат содержит статус (fulfilled/rejected) и, в зависимости от статуса, значение или причину отказа.
// Полезен, когда нужно обработать результаты всех Promise, даже если некоторые завершились ошибкой.
// Пример использования Promise.allSettled
// Используется в сценариях, где необходимо дождаться выполнения всех задач, даже если некоторые из них завершатся с ошибкой. Например, можно использовать для выполнения нескольких запросов к различным API и обработки каждого результата отдельно.
// Promise.race
// Promise.race: выполняет массив Promise’ов и возвращает результат первого исполненного Promise, независимо от того, завершился он успехом или ошибкой.
// Полезен в ситуациях, когда необходим результат от самого быстрого источника, например, при выборе наиболее быстрого сервера для загрузки данных.
// Примеры использования
// Сценарий с несколькими серверами: Используется Promise.race для определения и использования данных от самого быстрого сервера из предоставленного списка, улучшая тем самым производительность.
// Заключение
// Разработчики JavaScript могут использовать различные статические методы Promise для управления параллельными операциями, учитывая их предпочтения и специфику задач: Promise.all для сценариев, где важно успешное выполнение всех задач, Promise.allSettled для ситуаций, требующих результатов всех операций независимо от их исхода, и Promise.race для получения данных от первого выполненного обещания.