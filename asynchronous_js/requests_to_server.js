'use strict'

const URL = `https://dummyjson.com/products`



function req(id) {
  const request = new XMLHttpRequest()
  request.open('GET', URL + `/${id}`)
  request.send()

  request.addEventListener('load', function () {
    console.log(JSON.parse(this.response))
  })
}


req(1)
req('')
req(3)
console.log('end')

//Общий Обзор
// Цель: Изучить, как делать запросы на бэкэнд.
// Инструмент: Использование damage.json и XMLHttpRequest.
// Ключевые Понятия
// damage.json: Файл, доступный для запросов со всех доменов благодаря политике Cross-Origin Requests, практикуемся на этом файле.
// XMLHttpRequest: Метод для отправки запросов. Используется, несмотря на наличие современных альтернатив как fetch, важен для работы с Legacy кодом.
// Отправка Запроса
// Создание объекта XMLHttpRequest.
// Инициализация соединения с сервером через метод open, указание метода запроса (get) и URL.
// Отправка запроса методом send.
// Слушаем ответ сервера через addEventListener и обрабатываем его.
// Работа с Ответом
// После получения ответа, превращаем текст ответа в JSON объект (JSON.parse), для доступа к данным.
// Асинхронность и Последовательность Запросов
// Пример асинхронности запросов: отправка нескольких запросов подряд, но их выполнение и ответы не гарантируют последовательное получение.
// Проблема: Если требуется последовательное выполнение запросов, обычный подход через XMLHttpRequest не оптимален.
// Проблемы Callback и Решения
// Callback Hell: Сложность управления последовательностью асинхронных вызовов.
// Современные решения: Переход на fetch, применение async/await для удобства последовательной обработки запросов и избегания "callback hell".