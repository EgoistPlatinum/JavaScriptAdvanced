'use strict'

class Weapon {
  cost;

  dealDamage() {
  }
}

class Rifle extends Weapon {
  shoot() {
    this.dealDamage()
  }
}

class Sword extends Weapon {
  strike() {
    this.dealDamage()
  }

}

//Цель Лекции: Объяснить важность разделения интерфейса и как это помогает избежать ненужной зависимости классов от интерфейсов, содержащих методы, которые им не требуются.
//
// Часть 1: Плохой Пример
// Задача: Проектирование оружия (меч и лук).
// Проблема: Общий класс Weapon с методами strike и shoot, подходящими не для всего оружия.
// Пример: Rifle логично использует стрельбу, но меч не может стрелять.
// Результат: Создание класса Weapon с избыточными методами приводит к overengineering и нарушению принципа.
// Часть 2: Принцип Разделения Интерфейса
// Основная Идея: Классы не должны зависеть от методов, которые им не нужны.
// Цель: Минимизировать содержание в классе Weapon, оставив только общенеобходимые методы.
// Примеры Общих Методов: Стоимость в золотых монетах, методы чистки и обновления оружия.
// Часть 3: Правильное Проектирование
// Подход: Исключить из Weapon специфические методы типа стрельбы или удара.
// Решение для Оружия:
// В класс Weapon переместить только те методы, которые подходят всем видам оружия.
// Для каждого типа оружия (например, меч и винтовка) предусмотреть специфические методы обработки действий.
// Общий Метод: dealDamage может быть общим методом, подходящим всем, с разными способами активации.
// Заключение
// Применение принципа разделения интерфейса позволит создавать более гибкие и поддерживаемые системы. Данный подход предотвращает излишнюю загруженность классов ненужными методами и способствует точному разграничению ответственности между различными элементами программы.