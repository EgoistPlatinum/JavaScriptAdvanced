'use strict'

console.log('1')

setTimeout(() => console.log('2'), 0)

Promise.resolve().then(() => {
  console.log('3')
  for (let i = 0; i < 1000000000; i++) {

  }
})

console.log('4')
for (let i = 0; i < 1000000000; i++) {

}

// Цель эксперимента
// Продемонстрировать приоритетность Microtasks Queue (очередь микрозадач) по сравнению с Callback Queue (очередь коллбэков) и общее понимание работы Event Loop.
//
// Этапы эксперимента
// Инициализация: Вывод в консоль сообщения о старте (обозначено как 1).
// Выполнение синхронных и асинхронных операций:
// Введение конечного синхронного действия (обозначено как 4).
// Вставка асинхронного действия с setTimeout (должно возвращать 2 после 0 секунд).
// Добавление обработчика Promises, который также должен возвращаться мгновенно и выводить 3.
// Объяснение порядка выполнения:
// Синхронные операции 1 и 4 выполняются первыми.
// За ними следуют асинхронные операции, начиная с Promise, благодаря приоритету Microtasks Queue.
// setTimeout вне зависимости от указанного времени ожидания (0 секунд) будет выполняться после выполнения Promises.
// Результаты эксперимента
// После запуска кода наблюдаем последовательность выполнения: 1, 4 (синхронные), затем 3 (Promise, microtask), и в заключение 2 (setTimeout, callback).
//
// Анализ воздействия блокирующих операций
// Демонстрация, как длинная синхронная операция (цикл for), может заблокировать выполнение асинхронных задач, влияя на время их запуска.
// Объяснение, что setTimeout с нулевой задержкой не гарантирует мгновенное выполнение из-за возможных блокировок и задач в очереди.
