'use strict'

const promise = new Promise((resolve, reject) => {
  if (new Date() < new Date(2026, 11, 11)) {
    reject(new Error('Error'))
  }
  resolve('Success')
})

promise
  .then((data) => console.log(data))
  .catch((err) => console.log(err))


function timeout(sec) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve()
    }, 1000 * sec)
  })
}

timeout(3).then(() => console.log('Done'))

//Введение в промисы
// Основы: Промисы позволяют управлять асинхронным кодом.
// Создание промиса: Используйте конструктор new Promise с функцией, которая принимает два аргумента: resolve (успех) и reject (ошибка).
// Пример создания промиса
// Создание переменной prom:
// Пример: let prom = new Promise((resolve, reject) => { ... });
// Логика в промисе:
// Можно выполнить асинхронные операции.
// Вызов resolve(value) завершает промис с успехом.
// Вызов reject(error) завершает промис с ошибкой.
// Работа с промисом
// Обработка результата:
// Используйте .then(data => ...) для обработки успешного выполнения.
// Передайте результат в resolve для доступа в .then.
// Обработка ошибок:
// Используйте .catch(error => ...) для обработки ошибок.
// Усовершенствованный пример: обработка ошибок
// Правильная генерация ошибок:
// Вместо передачи строки передавайте объект ошибки в reject(new Error('сообщение об ошибке')).
// Это позволяет более эффективно работать с ошибками.
// Промисы для оборачивания API с коллбэками
// Цель: Упростить работу с API, применяя промисы вместо коллбэков.
// Пример: Создание обёртки для setTimeout с использованием промисов.
// Создание функции с таймаутом
// Функция timeout:
// Принимает время в секундах.
// Возвращает промис, который разрешается после указанного времени.
// Использование функции timeout
// Цепочка вызовов:
// Можно создавать последовательные задержки с выводом данных.
// Пример: Последовательное ожидание секунды и вывод результата.