'use strict'

class Book {
  constructor(title, author) {
    this.title = title;
    this.author = author;
  }

  info(){
    console.log(`${this.title} - ${this.author}`)
  }
}

const book1 = new Book('Lord of the Rings', 'Tolkien')

book1.info()

class EBook  extends Book {
  constructor(title, author, pages) {
    super(title, author);
    this.pages = pages;
  }
  info(){
    console.log(`${this.title} - ${this.author} - ${this.pages}`)
  }
}

const book2 = new EBook('Lord of the Rings', 'Tolkien', 1000)

book2.info()

//Введение: Override (переопределение) метода или свойства позволяет изменять их реализацию в классе-наследнике по сравнению с классом-родителем. Это необходимо для того, чтобы изменить поведение или добавить функционал, сохраняя при этом исходный интерфейс.
//
// Пример на базе концепции книг:
//
// Имеется базовый класс Book с методом info(), выводящим информацию о книге.
// Создается класс EBook, расширяющий класс Book, с добавлением свойств, таких как количество страниц в электронном формате.
// Чтобы включить дополнительную информацию в метод info для EBook, необходимо использовать переопределение (override) этого метода.
// Как работает override:
//
// В классе EBook создается метод info(), имеющий тот же идентификатор, что и в классе Book.
// В этом методе info() класса EBook добавляется вывод дополнительной информации, например, о количестве страниц.
// Когда метод info() вызывается для объекта класса EBook, используется переопределенная версия метода, обеспечивающая расширенный вывод информации.
// Важность сохранения сигнатуры:
//
// При переопределении метода важно сохранять его "сигнатуру" - тип возвращаемых данных и параметры. Это позволяет избежать путаницы и ошибок при использовании метода.