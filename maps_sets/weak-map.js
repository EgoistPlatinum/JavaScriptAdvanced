'use strict';

const map = new WeakMap()

let a = {a: 1}
let b = {b: 1}

map.set(a, 'testA')
map.set(b, 'testB')

console.log(map.get(a))
console.log(map.has(a))

a = null

b = {b: 3}

// console.log(map)

let cache = new WeakMap()

function getValue(obj) {
  if (!cache.has(obj)) {
    const res = 1 // сложные вычисления
    cache.set(obj, res)
  }

  return cache.get(obj)
}

const res = getValue(b)

console.log('res', res)

const res2 = getValue(b)

console.log('res2', res2)

// Конспект
// Основы:
//
//   Введены в ES6.
//   Полезны для реализации кэша.
//   Создаются с new WeakMap().
//   Особенности и отличия от Map:
//
//   Методы ограничены: доступны только delete(), get(), has(), и set(). Нет метода size.
//   Ключи только объекты: в отличие от Map, где ключом может быть любой тип данных, WeakMap принимает только объекты в качестве ключей.
//   Автоочистка: ключ-значение автоматически удаляется из WeakMap, как только на объект-ключ нет больше ссылок (сборка мусора).
// Пример использования:
//
//   Создание WeakMap.
//   Добавление элементов. Попытка использовать не объект как ключ приведет к ошибке.
//   Автоматическое удаление элементов при потере ссылок на ключ-объект.
//   Применение в кэшировании:
//
//   Функция getValue проверяет наличие значения в кэше и вычисляет его при отсутствии, сохраняя результат в кэш.
//   Пример демонстрирует, как результат сохраняется и извлекается из кэша без повторных вычислений.
//   Автоочистка кэша при потере ссылок на ключ-объект упрощает управление памятью.
//   Ограничения WeakMap:
//
//   Невозможность итерирования по элементам или получения размера коллекции, что делает WeakMap менее гибким в некоторых случаях по сравнению с обычными Map.