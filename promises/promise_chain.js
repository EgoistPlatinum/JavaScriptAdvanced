'use strict'

// Основные Моменты
// Пример с Fetch-запросами
// Демонстрация последовательной обработки данных из асинхронных запросов через Promise, используя API fetch для получения информации о продуктах.
// Пример показывает, как сначала осуществляется запрос на получение списка продуктов, а затем - на получение детальной информации о первом продукте из списка.
// Углубление в Promise
// Объяснение того, как метод then Promise может возвращать новый Promise, позволяя формировать цепочки асинхронных операций без вложенных вызовов.
// Демонстрация возможности метода then возвращать любые значения, не ограничиваясь Promise, и как эти значения обрабатываются в последующих then.
// Избегание Повторения Callback Hell
// Критический взгляд на формирование вложенных структур при использовании then, что напоминает "callback hell".
// Пояснение, как правильное использование возврата Promise из then позволяет избежать этого и делает код более чистым и понятным.

// const res = fetch('https://dummyjson.com/products')
//   .then(
//     response => response.json(),
//   )
//   .then(({products}) => {
//     return fetch('https://dummyjson.com/products/' + products[0].id)
//       .then(response => response.json())
//       .then((data) => console.log(data))
//   })
//Обработка reject
//Введение к проблеме
// В программировании важно уметь обрабатывать ошибки, особенно при работе с внешними данными. Примеры таких ошибок: сервер возвращает код 404, неправильное преобразование JSON, обращение к несуществующему домену.
// Демонстрация ошибок
// Изменение URL для имитации ошибки с доменом, приводящей к ошибке.
// Попытка обработать несуществующий JSON возвращает ошибку в промисе (uncaught error in promise), подчеркивая важность обработки ошибок.
// Способы обработки ошибок
// Локальная обработка ошибок:
// Использование двух аргументов в then(): первый для успешной обработки, второй для ошибок.
// Пример с восстановлением валидного URL и добавлением локальной обработки ошибки на следующем этапе.
// Демонстрация ошибки при невозможности разбора JSON (например, 404 с кодом статуса не является JSON).
// Глобальная обработка ошибок:
// Рассмотрение использования catch() для обработки всех ошибок в цепочке промисов.
// Отличие catch() от then(): catch() является общим обработчиком для любых ошибок в цепочке.
// Рекомендации
// Выбор между локальной и глобальной обработкой зависит от ситуации: если последствия ошибки различаются в зависимости от этапа, подходят локальные обработчики; для единообразной реакции на ошибки лучше подходит глобальный обработчик с catch().
// Размещение catch() в конце цепочки промисов для глобальной обработки ошибок обеспечивает, что после обработки ошибки выполнение кода не будет продолжено в последующих then().

// const res = fetch('https://dummyjson.com/productss')
//   .then(
//     response => {
//       console.log(response)
//       return response.json()
//     },
//     // error => console.log(error)
//   )
//   .then(({products}) => {
//     console.log(products)
//     return fetch('https://dummyjson.com/products/' + products[0].id)
//       .then(response => response.json())
//       .then((data) => console.log(data))
//   })
//   .catch(error => console.log(error))

//Finally
// Обзор Проблемы
// В работе с промисами выделяют три основных сценария:
//
// Успешное выполнение запроса - когда всё прошло без ошибок.
// Неудачное выполнение запроса - возникновение ошибки в процессе выполнения.
// Действия, необходимые после выполнения запроса независимо от результата - выполнение специальных манипуляций не зависимо от того, была ошибка или нет (например, отображение информационной плашки о попытке выполнения).
// Решение Проблемы
// Повторение кода - это результат попытки реализовать поведение для третьего сценария, добавляя один и тот же код как в обработчик успешного выполнения (.then()), так и в обработчик ошибки (.catch()). Чтобы избежать дублирования кода, следует использовать принцип DRY (Don’t Repeat Yourself - Не повторяйся).
//
// Введение в finally
// Определение: метод .finally() - это специальный метод промисов, который позволяет выполнять некоторые действия после завершения промиса, независимо от его результата (ошибка или успешное выполнение).
// Применение: блок .finally() используется для кода, который должен выполниться после завершения промиса, дублирование которого в блоках .then() и .catch() было бы излишним.
// Расположение: Порядок следования методов .catch(), .then(), и .finally() имеет значение. Обычно, .finally() располагается в конце, чтобы гарантировать выполнение кода после обработки промиса независимо от его исхода.
// Примеры Использования
// Отображение сообщения о попытке выполнения запроса независимо от его успеха или неудачи.
// Выполнение чистых операций, таких как закрытие соединения или уведомление системы мониторинга.
const res = fetch('https://dummyjson.com/productss')
  .then(
    response => {
      console.log(response)
      return response.json()
    },
    // error => console.log(error)
  )
  .then(({products}) => {
    console.log(products)
    return fetch('https://dummyjson.com/products/' + products[0].id)
      .then(response => response.json())
      .then((data) => console.log(data))
  })
  .catch(error => console.log(error))
  .finally(() => console.log('finally'))