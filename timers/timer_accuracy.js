'use strict'

// console.log(performance.now())

const mark1 = performance.now()


setTimeout(() => {
  const mark2 = performance.now()
  console.log(mark2 - mark1)
}, 1000)

// Введение
// Цель лекции – показать, почему JavaScript-таймеры (например, setTimeout) могут быть неточными.
//   Упомянута важность измерения производительности, особенно на бэкенде, но подробности будут опущены из-за ограниченности времени и обширности материала.
//   Измерение времени выполнения
// Для измерения используется performance.now(), функция, возвращающая количество миллисекунд с момента начала выполнения приложения.
//   Пример использования performance.now() до и после setTimeout с задержкой в 1000 мс (1 секунда) демонстрирует, что фактическая задержка может быть больше запланированной.
//   Причины неточности
// Event Loop: JavaScript-интерпретатор использует модель событийного цикла (event loop), влияющую на выполнение таймеров.
//   Когда таймер достигает своего времени, реальное выполнение может задержаться, так как event loop должен завершить текущее выполнение кода и проверить наличие других задач или событий перед выполнением задачи таймера.
//   Это означает, что setTimeout гарантирует задержку как минимум на указанное время, но фактическая задержка может быть больше в зависимости от загрузки event loop.